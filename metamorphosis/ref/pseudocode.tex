%\nonstopmode
%\batchmode
\documentclass[a4paper,12pt]{article}
\usepackage{amsmath} % {split}
\usepackage{titlesec}
\usepackage{bm} %\bm
\usepackage{mathrsfs} % \mathscr
\usepackage{amsthm}  %\newtheorem
\usepackage{amssymb} %\mathbb
\usepackage{courier} %\ttfamily, \tttext
\usepackage{verbatim} % {comment} enviroment for multiline comments

% Define alorithm enviroment
\newtheorem{algorithm}{Algorithm}
\let\tempalg\algorithm
\renewcommand{\algorithm}{\tempalg\normalfont}

% Define listing enviroment
\newenvironment{listing}
{
  \ttfamily 		% Use Courier font in code listing
  \begin{tabbing} 	% Use tabbing in code listing
  \hspace*{1cm}\=\hspace*{1cm}\=\hspace*{1cm}\=\hspace*{1cm}\=\hspace*{1cm}\= \kill % Define tab stops for code listing
}
{
  \end{tabbing}
}

\newcommand{\norm}[1]{\left\lVert#1\right\rVert} 	% Define \norm
\newcommand{\lform}[2]{\left(#1\middle|#2\right)} 	% Define \lform
\newcommand{\inner}[2]{\left\langle #1,#2 \right\rangle}% Define\inner
\begin{document}

\section{LDDMM Algorithm}

\begin{algorithm}
 Let $\Omega \in \mathbb{R}^3$ be the background space.
 Let $I_0 : \Omega \rightarrow \mathbb{R}$ be a template image which will be deformed to match target image $I_1 : \Omega \rightarrow \mathbb{R}$.
 Let $\varphi_{t 0} = \int_{t}^0 v(t, \varphi_{t 0}) dt$ be the forward mapping, $\varphi_{t 1} = \int_{t}^1 v(t, \varphi_{t 1}) dt$ be the reverse maping where $v(t) : \Omega \rightarrow \mathbb{R}^3$ denotes the velocity of the flow.
 Thus $I(t) = I_0 \circ \varphi_{t 0}$ is the forward deformed template image.
 Furthermore let $\bm{K_V}$ be the kernel used to smooth velocity fields.
 We discretize time domain $[0,1]$ so that $t_0 = 0$ and $t_{J-1} = 1$ where $J$ is the number of time steps.
 The optimal flow $v^*$ is estimated using a \emph{gradient descent} algorithm below.
 
 \begin{listing}

  $v = 0$, $v_{old} = 0$, $E_{old} = \infty$, $\varepsilon =$ SMALL, $\varepsilon_{min} =$ SMALLER \\
  while $k <$ MAX\_ITERATIONS \\
  \\
  \> // Calculate energy gradient. \\
  \> foreach $j \in \{0,\ldots,J-1\}$ \\
  %\>\>$\varphi_{t_j 0} = \int_{t_j}^0 v(t_j, \varphi_{t_j 0}) dt$\\
  %\>\>$\varphi_{t_j 1} = \int_{t_j}^1 v(t_j, \varphi_{t_j 1}) dt$\\
  \>\>$p(t_j) = -\frac{1}{\sigma^2} \left( I_0\circ\varphi_{t_j 0} - I_1 \circ \varphi_{t_j 1} \right) |D\varphi_{t_j 1}|$ \\
  \>\>$I(t_j) = I_0 \circ \varphi_{t_j 0}$\\
  \>$\nabla_v E = v + \bm{K_V}[p\nabla I]$\\
  \\

  \> // Update velocity using energy gradient. \\
  \> while True\\
  \>\> $v = v - \varepsilon \nabla_v E $ // Take a step.\\
  %\> // Update energy\\
  \>\> $E(v) = \frac{1}{2}\int_0^1 \norm{v(t)}_V^2 dt + \frac{1}{2\sigma^2}\norm{I(1) - I_1}_{L_2}^2$ \\
  \>\> if $E(v) < E_{old}$ // If energy decreased...\\
  \>\>\> $\varepsilon = \varepsilon * 1.05 $ // ...increase step size...\\
  \>\>\> $(v_{old},E_{old}) = (v,E(v))$ // ...and save old values.\\ 
  \>\>\> BREAK \\
  \>\> else // If energy increased...\\
  \>\>\> $v = v_{old}$  // ...restore old velocity...\\
  \>\>\> $\varepsilon = \varepsilon * 0.5 $ // ...and decrease step size...\\
  \>\>\> if $\varepsilon < \varepsilon_{min}$  // ...but stop if min step size reached. \\
  \>\>\>\> $v^* = v$ \\
  \>\>\>\> STOP \\

 \end{listing}
\end{algorithm}

\end{document}
